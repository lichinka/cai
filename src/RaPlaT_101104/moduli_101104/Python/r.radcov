#!/usr/bin/env python

############################################################################
#
# MODULE:      r.radcov
# AUTHOR(S):   Igor Ozimek, Jozef Stefan Institute
#
# PURPOSE:     Main script for radio coverage simulation
#
# COPYRIGHT:   (C) 2010 Jozef Stefan Institute
#
#############################################################################
#
# Requires Python 2.4 or higher (tested with 2.4.3)
#
#
# Revision history:
#
# 22-jan-10:
#  - during model/sector simulation display sector name (userLabel) and number of current/all simulated
#    models or sectors
#  - changed model and sector filenames, sector names now include (start with) the sector name (userLabel)
#    model filenames start with a leading underline
#
# 26-jan-10:
#  - options not used in the "frequency" parameter definition (limits allowed values to options value only)
#    default value remains 900 MHz
#  - db.GenerateTable and r.MaxPower not called if nothing to do (empty sector list)
#  - sector names as appearing in sector filenames are modified: any underline character is deleted
#    (this can possibly lead to duplicate sector names, but they are there only for human readibility)
#
# 29-jan-10:
#  - output table filename check according to the following rules:
#      supported table name characters are only: [A-Za-z][A-Za-z0-9_]*  (regular expression)
#      a table name must start with a character, not a number
#  - the above rule applies also to the output map file (just in case...)
#  - usrLabel string (sector name) is now also checked; new string type 'ul' is introduced for this purpose;
#    only teh following characters are allowed in usrLabel: 'A..Z', 'a..z', '0..9', '_', '-'
#  - modified allowed ranges (in cellTableDescrib):
#      electricalTiltAngle 0..10 (degrees)
#      power 0..50 (dBm - 1mW..100W)
#  - rules definition (cellTableDescrib) moved up, right after the module definition (grass.parser) part below
#
# 16-feb-10:
#  - radius value added to the model/sector filenames
#  - changed calling of (the new) r.sector - antennas folder parameter included (and default location changed)
#  - changed default input parameter values - CSV, DEM and clutter file names
#
# 24-feb-10:
#  - using new versions of db.CreateTable and r.MaxPower (supporting other databases besides dbf - e.g. MySQL)
#    additional input parameters for database driver and database (directory)
#
# 18-mar-10:
#  - modification for compatibility with GRASS 6.2 (originally the script was developed for GRASS 6.4)
#      appends path to grass.py module to python path (if not already there - as in the case of GRASS 6.4)
#      for GRASS 6.2: the modified grass.py module (the original is from GRASS 6.4) must be put in the same
#        directory as in GRASS 6.4 ($GISBASE/etc/python)
#  - changed default name and location of the antenna diagrams directory ($GISBASE/etc/antenna_diagrams)
#
# 9-avg-10  (a major new version):
#  - support for parallel (multicore) processing
#  - a new flag -c (check): test run only, without actually performing radio coverage computation
#  - command line parameter keywords changed according to GRASS standards
#    (lower case letters, underline as optional separatator)
#  - @MAPSET appended to GRASS input raster filenames for r.sector and r.MaxPower
#    (in the r.sector commands and in the sector file list for r.MaxPower)
#    this is to suppress possible warnings in case of duplicate model or sector filenames in other mapsets
#  - additional messages to report script execution progress
#  - times needed to compute models, sectors, and r.MaxPower are reported
#    (these are elapsed times, not the actual processing times - they depend on other running processes)
# The following changes require modifications to other radio coverage modules:
#  - use of the antennas map file to map antennas type and tilt to .MSI files
#    (instead of r.sector performing <antenna_type & el_tilt> to <.MSI_filename> translation by an internal algorithm)
#  - region management: computation region can be defined (set as temporal current region)
#    all coverage computations should be made within current region (instead of within input dem_map region),
#    requires changes to all coverage computation modules (models, r.sector, r.MaxPower)
#  - optional output data table creation (none if db_driver=_none_, modification of r.MaxPower is required) 
#
# 30-sep-10
#  - tested and corrected to actually work with the new versions of radio coverage computation modules
#  - additon of default_height and default_clutter parameters
#  - command line parameter value type checking
#    (grass parser does not check value types, e.g. for integer parameters)
#  - support (with automatic recognition) for the standard CSV format (delimiter ',') and
#    Microsoft Euro version (delimiter ';'=) (previuously only the MS Euro version was supported)
#  - region "refinement" (aligned to resolution, etc) for definiton options (previously only for current)
#  - dbdriver option _none_ changed to none
#
# 8-oct-10
#  - region "refinement" (alignment) algoritm changed (GRASS's built in g.region -a res=... doesn't work well)
#
# 15-oct-10
#  - cells within (extended) computation region but with transmitter location not defined in DEM are removed
#    from simulation, with warnings generated
#
# 22-oct-10
#  - corrected calling of r.sector: radius parameter missing - added
#  - "%" progress substrings postprocessing (removing) emproved (parallel processing only)
#  - added support for r.waik (Walfisch-Ikegami)
#  - updated/improved computation region management, 'dem' option added (default)
#
# 29-oct-10
#  - parameter P5 added to the models' (and sectors') filenames
#  - parameter P5 added to the temporary intermediate file for r.MaxPower


#%module
#%  label: r.radcov
#%  description: Radio coverage simulation
#%end

#%option
#%  key: csv_file
#%  type: string
#%  gisprompt: old_file,file,input
#%  description: Radio cell/sector table in CSV format
#%  required: yes
#%  answer: sector_table.csv
#%end

#%option
#%  key: antmap_file
#%  type: string
#%  gisprompt: old_file,file,input
#%  description: Antennas map file
#%  required: yes
#%  answer: $GISBASE/etc/radio_coverage/antennamap
#%end

#%option
#%  key: dem_map
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: DEM file for radio coverage simulation
#%  required: yes
#%  answer: dem_map@PERMANENT
#%end

#%option
#%  key: default_height
#%  type: integer
#%  description: Default DEM height
#%  required: no
#  answer: 0
#%end

#%option
#%  key: clutter_map
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Clutter map file (required for Ericsson model)
#%  required: no
#%  answer: clutter_map@PERMANENT
#%end

#%option
#%  key: default_clutter
#%  type: integer
#%  description: Default clutter attenuation
#%  required: no
#  answer: 0
#%end

#%option
#%  key: region
#%  type: string
#%  description: Computation region (dem,current or region,rast,n,e,s,w,res (see g.region))
#%  answer: dem
#%  required: no
#%end

#%option
#%  key: frequency
#%  type: integer
#%  description: Radio frequency
#  options: 900,1800
#%  answer: 900
#%  required: yes
#%end

#%option
#%  key: cellnum
#%  type: integer
#%  description: Number of succesive path loss values to be written in the table
#%  required: yes
#%  answer: 5
#%end

#%option
#%  key: out_map
#%  type: string
#%  gisprompt: new,cell,raster
#%  description: Simulated radio coverage - raster (output)
#%  required: yes
#%  answer: out_raster
#%end

#%option
#%  key: db_driver
#%  type: string
#%  description: Database driver
#%  required: yes
#%  options: none,dbf,mysql,pg
#%  answer: none
#%end

#%option
#%  key: database
#%  type: string
#%  description: Database name
#%  required: yes
#%  answer: $GISDBASE/$LOCATION_NAME/$MAPSET/dbf
#%end

#%option
#%  key: out_table
#%  type: string
#%  gisprompt: new_dbtable,dbtable,dbtable
#%  description: Simulated radio coverage - db table (output)
#%  required: yes
#%  answer:out_db
#%end

#%option
#%  key: procnum
#%  type: integer
#%  description: Number of parallel processes (-1: automatic, 0: non-parallel)
#%  answer: -1
#%  required: no
#%end

#%flag
#%  key: recalculate
#%  description: Recalculate all sector radio coverage files
#%end

#%flag
#%  key: purge
#%  description: (purge) Delete all unused sector radio coverage files
#%end

#%flag
#%  key: check
#%  description: (check) Test run without actually performing radio coverage computation
#%end



# ---- RULES DEFINITION FOR THE INPUT (CSV) TABLE ----

cellTableDescrib = [
                    ['userLabel', 'ul'],
                    ['beamDirection', 'i', [0, 360]],
                    ['electricalTiltAngle', 'i', [0, 10]],
                    ['mechanicalAntennaTilt', 'i', [-90, +90]],
                    ['heightAGL', 'f', [0., 300.]],
                    ['antennaType', 'i', [742200, 742399]],
                    ['positionEast', 'i', [400000, 600000]],
                    ['positionNorth', 'i', [100000, 200000]],
##                    ['positionEast', 'i', [0, 0]],
##                    ['positionNorth', 'i', [0, 0]],
                    ['power', 'f', [0., 50.]],
                    ['radius', 'f', [0., 100.]],
                    ['model', 's', ['hata'],['cost231'],['ericsson'],['waik']],
                    ['P1', 's', ['urban', 'suburban', 'open'],\
                           's', ['metropolitan', 'medium_cities'],\
                           'f', [0., 0.],\
                           's', ['metropolitan', 'medium_cities']],
                    ['P2', '-', '-', 'f', [0., 0.], 'i', [10, 25]],
                    ['P3', '-', '-', 'f', [0., 0.], 'i', [20, 50]],
                    ['P4', '-', '-', 'f', [0., 0.], 'i', [0, 300]],
                    ['P5', '-', '-', '-',           'i', [0, 180]]
                   ]



import os, sys
if not os.environ.has_key("GISBASE"):
    print "You must be in GRASS GIS to run this program."
    sys.exit(1)


# the following is required for GRASS 6.2 (does nothing for GRASS 6.4)
# (GRASS 6.4 contains module grass.py in its etc/python directory and extends python path accordingly)
phytpath = os.environ['GISBASE'] + '/etc/phyton'
if not phytpath in sys.path:
    sys.path.append(phytpath)


import grass
options, flags = grass.parser()

mapset = grass.gisenv()['MAPSET']
#workDir = grass.gisenv()['GISDBASE'] + '/' + grass.gisenv()['LOCATION_NAME'] + '/' + mapset


# check output table and map filenames
import re

outFilename = options['out_map']
if re.match(r'[A-Za-z][A-Za-z0-9_]*\Z', outFilename) == None:
    grass.fatal('Wrong output map filename (=' + outFilename + ')\n' +
                "allowed chars: 'A-Z', 'a-z', '0-9', and '_' (not as the first char)")

dbFilename = options['out_table']
if re.match(r'[A-Za-z][A-Za-z0-9_]*\Z', dbFilename) == None:
    grass.fatal('Wrong output table filename (=' + dbFilename + ')\n' +
                "allowed chars: 'A-Z', 'a-z', '0-9', and '_' (not as the first char)")


# check numeric arguments values (grass parser does not perform this)
intArgList = ['frequency', 'cellnum', 'procnum']
optIntArgList = ['default_height', 'default_clutter']
for optKey in (intArgList + optIntArgList):
    optStr = options[optKey]
    if optKey in optIntArgList:
        if optStr == '':
            break
    try:
        int(optStr)
    except:
        grass.fatal('Non-integer value for integer parameter: ' + optKey + '=' + optStr )


# ---- SET THE NUMBER OF PARALLEL PROCESSES
# ---- used for parallel computations of model and sectors

# detectCPU is from:
#   http://www.artima.com/weblogs/viewpost.jsp?thread=230001
#   Computing Thoughts
#   Concurrency with Python, Twisted, and Flex
#   by Bruce Eckel
#   May 3, 2008

def detectCPUs():
    """
    Detects the number of CPUs on a system. Cribbed from pp.
    """
    # Linux, Unix and MacOS:
    if hasattr(os, "sysconf"):
        if os.sysconf_names.has_key("SC_NPROCESSORS_ONLN"):
            # Linux & Unix:
            ncpus = os.sysconf("SC_NPROCESSORS_ONLN")
            if isinstance(ncpus, int) and ncpus > 0:
                return ncpus
        else: # OSX:
            return int(os.popen2("sysctl -n hw.ncpu")[1].read())
    # Windows:
    if os.environ.has_key("NUMBER_OF_PROCESSORS"):
            ncpus = int(os.environ["NUMBER_OF_PROCESSORS"]);
            if ncpus > 0:
                return ncpus
    return 1 # Default

#----------------

parNum = int(options['procnum'])
if parNum < 0:
    parNum = detectCPUs()
    grass.info('\nNumber of detected processors = ' + str(parNum))



# ---- BUILD THE ANTENNAS MAP DICTIONARY

grass.info('\nBUILDING THE <ANTENNA_TYPE & EL_TITLE> TO <.MSI_FILE> MAPPING TABLE ...')

# get the name of the antenna map file from the parameter (or default)
inPathname = options['antmap_file']
# evaluate GISBASE enviroment variable
gisBase = os.getenv('GISBASE')
inPathname = inPathname.replace('$GISBASE',gisBase)
# create full absolute path for inPathname
inPathname = os.path.join(gisBase + '/etc/radio_coverage', inPathname)

# read in the antenna map file
try:
    amFile = open(inPathname, 'r')
    amLines = amFile.readlines()
    amFile.close()
except IOError, (errno, strerror):
    grass.fatal('Cannot open or read input file:\n' + inPathname + '\nError no. ' + str(errno) + ', ' + strerror)
    sys.exit(1)

# process antenna map file
msiDirname = gisBase + '/etc/radio_coverage/antenna_diagrams'
mappings = []
tiltCheckList = []
antDict = {}
warnCount = 0
errCount = 0
for ixl, line in enumerate( amLines):
    line = line.rstrip()
    errMsg = ''
    warnMsg = ''

    if line == '':
        continue  #empty line

    if line[0] == '#':
        continue  #comment only line

    lineWords = line.split(None,1)

    if lineWords[0] == '_directory_':
        # _directory_ line
        lineWords = line.split(None,2)
        if len( lineWords) < 2:
            errMsg += '  Missing directory name in the _directory_ line\n'
        else:
            dirname = lineWords[1]
            comment = '#'
            if len( lineWords) > 2:
                comment = lineWords[2]
            if dirname[0] == '#':
                errMsg += '  Missing directory name in the _directory_ line\n'
            else:
                # evaluate GISBASE enviroment variable
                msiDirname = dirname.replace('$GISBASE',gisBase)
                # check for directory existence
                if not os.path.isdir(msiDirname):
                    warnMsg += '  .MSI files directory (' + msiDirname + ') does not exist\n'
                # parameters past the directory name ?
                if comment[0] != '#':
                    warnMsg += '  Superfluous parameter(s) (' + comment + ') in the _directory_ line\n'

    else:
        # mapping line
        lineWords = line.split(None,3)
        if len( lineWords) < 3:
            errMsg += '  Missing tilt value and/or .MSI filename in the antenna mapping line\n'
        else:
            name = lineWords[0]
            tilt = lineWords[1]
            msiFilename = lineWords[2]
            comment = '#'
            if len( lineWords) > 3:
                comment = lineWords[3]
            if tilt[0] == '#':
                errMsg += '  Missing tilt value in the antenna mapping line\n'
            if not tilt.isdigit():
                errMsg += '  Tilt value (' + tilt + ') should be integer\n'
            else:
                tiltValue = int(tilt)
                if msiFilename[0] == '#':
                    errMsg += '  Missing .MSI filename in the antenna mapping line\n'
                else:
                # check for the .MSI file existence
                    msiPath = os.path.join(msiDirname, msiFilename)
                    if not os.path.isfile(msiPath):
                        warnMsg += '  .MSI file (' + msiPath + ') does not exist\n'
                    # parameters past the .MSI filename ?
                    if comment[0] != '#':
                        warnMsg += '  Superfluous parameter(s) (' + comment + ') in the antenna mapping line\n'

        # check for duplicated (name,tilt) definitions
        if errMsg == '':
            for [mIxl, mName, mTiltValue] in mappings:
                if mName == name and mTiltValue == tiltValue:
                    if errMsg != '':
                        print '??? INTERNAL ERROR - duplicated (name,tilt) entries in the mapping list ?'
                    errMsg += '  Duplicated name & tilt definition - already defined in the antenna mapping file, line ' + str(mIxl+1) + '\n'
            # add to the mapping list
            if errMsg == '':
                mappings.append([ixl, name, tiltValue])
                if warnMsg == '':
                    tiltCheckList.append([ixl, msiPath, tiltValue])
                    antDict[(name,tiltValue)] = msiPath


    # diagnostics
    if errMsg != '':
        grass.error('Line ' + str(ixl+1) + ':\n  ' + line + '\n' + errMsg.rstrip())
        errCount += 1
    if warnMsg != '':
        grass.warning('Line ' + str(ixl+1) + ':\n  ' + line + '\n' + warnMsg.rstrip())
        warnCount += 1

if errCount > 0 or warnCount > 0:
    grassMsg = 'Antennas mapping file ' + inPathname + ' has been checked\n'
    if errCount == 0:
        grassMsg += 'No errors'
    else:
        grassMsg += str(errCount) + ' error(s)'
    grassMsg += ' and '
    if warnCount == 0:
        grassMsg += 'no warnings'
    else:
        grassMsg += str(warnCount) + ' warning(s)'
    grassMsg += ' found\n'

    if errCount > 0:
        grass.fatal(grassMsg)
    else:
        grass.warning(grassMsg)


# Proceeding with the tilt agreement test for existing .MSI files
##print '*** MAPPINGS:'
##for l in mappings: print l
##print '*** TILTCHECKLIST:'
##for l in tiltCheckList: print l

if warnCount > 0:
    grass.info('Proceeding with the tilt agreement test for the existing .MSI files...')

#--------

def getValue(lineList, name):
    """ Find 'name' variable in 'lineList', return (1st) value, (1st) line number, and number of occurences """
    rValue = ''
    rLinenum = 0
    count = 0
    for cLinenum, cLine in enumerate(lineList):
        cName, cValue = cLine.split(None,1)
        cValue = cValue.strip().rstrip()
        if cName == name:
            count +=1
            if count == 1:
                rLinenum = cLinenum + 1
                rValue = cValue
                rValueList = cValue.split()
    return rValue, rLinenum, count

#--------


errFlag = False
for [ixl, msiPath, amTiltValue] in tiltCheckList:
    msiFilename = os.path.split(msiPath)[1]

    # get the electrical tilt from the .MSI filename (subtring '_nnT_' or '_nnT.MSI', where n=0..9)
    nnTvalueDefined = False
    msiFilenameNoext = os.path.splitext(msiFilename)[0]
    nnTlist = re.findall(r'_[0-9]{1,2}T(?:_|\Z)', msiFilenameNoext)
    if len(nnTlist) > 1: 
        grass.warning('There seem to be more than a single tilt definition in ' + msiFilename)
        continue
    elif len(nnTlist) == 1:
        nnTnumValue = int(nnTlist[0].strip('_T'))
        nnTvalueDefined = True

    # read in a .MSI file
    try:
        msiFile = open(msiPath, 'r')
        msiLines = msiFile.readlines()
        msiFile.close()
    except IOError, (errno, strerror):
        grass.fatal('Cannot open or read input file:\n' + msiFile + '\nError no. ' + str(errno) + ', ' + strerror)

    # get the tilt from the .MSI file
    # get the electrical tilt from the TILT variable:
    #   - if no TILT variabe: error
    #   - valid values are 0..90 (integer)
    #   - if value "electrical": ignore
    #   - all other values: error
    tiltValueDefined = False
    (tiltValue, line, count) = getValue(msiLines, 'TILT')
    if count > 1:
        errFlag = True
        grass.error('Multiple TILT variable definitions in ' + msiFilename)
        continue
    elif count == 1:
        if tiltValue == '':
            errFlag = True
            grass.error('TILT variable with no value in ' + msiFilename)
            continue
        if len(tiltValue.split()) > 1:
            errFlag = True
            grass.error('TILT variable with mulitple values in ' + msiFilename)
            continue
        if tiltValue.lower() == 'electrical':
            pass
        elif tiltValue.isdigit():
            tiltNumValue = int(tiltValue)
            if tiltNumValue < 0 or tiltNumValue > 90:
                errFlag = True
                grass.error('TILT value (=' + str(tiltNumValue) + ') out od bounds in ' + msiFilename + ' (0..90 allowed)')
                continue
            else:
                tiltValueDefined = True
        else:
            errFlag = True
            grass.error('Wrong TILT value in ' + msiFilename + "(only integer numeric or 'electrical' allowed)")
            continue


    # check tilt value agreement between the antennas mapping file and
    # .MSI files (filename and in-file TILT parameter are checked)
    if not nnTvalueDefined and not tiltValueDefined:
        grass.error('No tilt defined in ' + msiFilename)
        errFlag = True
    else:
        if (nnTvalueDefined  and nnTnumValue  != amTiltValue or
            tiltValueDefined and tiltNumValue != amTiltValue):
            errFlag = True
            grassMsg = 'Tilt values in line ' + str(ixl+1) + ' for file ' + msiFilename + ' disagree\n'
            grassMsg += 'Line ' + str(ixl+1) + ': ' + str(amTiltValue) + ',  '
            if nnTvalueDefined:
                grassMsg += '.MSI filename: ' + str(nnTnumValue) + ',  '
            else:
                grassMsg += '.MSI filename: (none),  '
            if tiltValueDefined:
                grassMsg += '.MSI file TILT parameter: ' + str(tiltNumValue)
            else:
                grassMsg += '.MSI file TILT parameter: (none)'
            grass.error(grassMsg)


if errFlag:
    grass.error('Tilt disagrement(s) found\n')
    sys.exit(1)
##else:
##    grass.info('Processing finished, no disagreements found\n')

##print '*** antDict: ', antDict



# ---- READ IN THE CSV TABLE ----
# ---- and check for duplicate userLabel (cell sector names) ---

grass.info('\nREADING AND CHECKING THE RADIO SECTOR CSV TABLE ...') 

import csv
#csvFile = open('./test_002.csv', 'r')
try:
    csvFile = open(options['csv_file'], 'r')
except IOError:
    grass.fatal('Cannot open Radio cell/sector input file')
    
#determine the type of CSV - standard (delimiter ',') or MS Euro (delimiter ';')
hline1 = csvFile.readline()
hline1 = re.sub(r'".*?"', '', hline1)  #remove quoted text
hStd = hline1.count(',') > 0
hMSE = hline1.count(';') > 0
if not hStd and not hMSE:
    grass.fatal('CSV file first line (header) error: no separator (commas or semicolons) found')
if hStd and hMSE:
    grass.fatal('CSV file first line (header) error: separator ambiguity - commas and semicolons found')
if hStd:
    grass.info('Standard CSV file format detected')
    csvReader = csv.reader( csvFile)
else:
    grass.info('MS Euro CSV file format detected')
    csvReader = csv.reader( csvFile, delimiter=';', quoting=csv.QUOTE_NONE)
csvFile.seek(0)

##csvReader = csv.reader( csvFile, delimiter=';', quoting=csv.QUOTE_NONE)


cellTable=[]
for row in csvReader:
    if row == []:
        continue
    for row2 in cellTable:
        if row[0] == row2[0]:
           grass.fatal('Duplicated userLabel (sector name) in input table:\n' + ', '.join(row) + '\n')
    if row[0][0] != '#':
        cellTable.append(row)    

csvFile.close()


# ---- CHECK AND REMOVE THE HEADER (the first line) ----

#refCellTableHeader = ['userLabel', 'beamDirection', 'electricalTiltAngle', 'mechanicalAntennaTilt', 'heightAGL', ...
refCellTableHeader = []
for clmnlist in cellTableDescrib:
    refCellTableHeader.append(clmnlist[0])

# extract and check the header (and delete it from the table)
cellTableHeader = cellTable[0]
if cellTableHeader != refCellTableHeader:
    _msgStr = 'Error in Cell Table header - should be:\n'
    _msgStr += str(refCellTableHeader)
    grass.fatal(_msgStr)
del cellTable[0]


# ---- CHECK PARAMETERS (the rest of each table row) ----

# checking the input (CSV) table according to the rules given by cellTableDescrib
# a bit tricky and hard-to-explain procedural part of code follows :(
err = False  # becomes True if one or more parameter errors are found in a a table row
for cellTableLine in cellTable:
    vix = 1  # variant index (=1 unless multi-variant column definitions are used)
    for tcix, clmnDescr in enumerate(cellTableDescrib):  # tcix: cellTable column index
        # find the (chosen variant of the) parameter description list for the current parameter (table column)
        ibegin = 1  # this will be the beginning of the (chosen variant of the) parameter description list
        iend = len(clmnDescr)  # this will be the end of the (chosen variant of the) parameter description list
        n = 0  # a local variant counter (for a column)
        for i in range(1, iend):
            if isinstance(clmnDescr[i], str):
                n += 1
                if n == vix:
                    ibegin = i
                    break
        for i in range( ibegin + 1, iend):
            if not isinstance( clmnDescr[i], list):
                iend = i
                break

        # extract the (chosen variant of the) parameter description list for the current parameter
        clmnDescSublist = clmnDescr[ibegin:iend]


        # process (check correctness of) parameters according to cellTableDescrib
        if clmnDescSublist == []:
            print '??? INTERNAL ERROR (cellTableDescrib) - empty (or to short) column description'
            sys.exit(1)

        # unchecked type
        elif clmnDescSublist[0] == '-':
            if len(clmnDescSublist) != 1:
                print "??? INTERNAL ERROR (cellTableDescrib) - type '-' should have no additional parameters"
                sys.exit(1)

        # numeric types (integer, float) - check against min and max allowed values
        elif clmnDescSublist[0] in ['i','f']:
            if len(clmnDescSublist) != 2:
                print "??? INTERNAL ERROR (cellTableDescrib) - type 'i' or 'f' should have one additonal parameter (list)"
                sys.exit(1)
            nerr = (len(clmnDescSublist[1]) != 2)
            if not nerr:
                nummin = clmnDescSublist[1][0]
                nummax = clmnDescSublist[1][1]
            if clmnDescSublist[0] == 'f':
                nerr = nerr or not isinstance(nummin, float) or not isinstance(nummax, float)
                if nerr:
                    print '??? INTERNAL ERROR (cellTableDescrib) - invalid floating number range definition ( = ', clmnDescSublist[1], ')'
                    sys.exit(1)
            else:
                nerr = nerr or not isinstance(nummin, int) or not isinstance(nummax, int)
                if nerr:
                    print '??? INTERNAL ERROR (cellTableDescrib) - invalid integer number range definition ( = ', clmnDescSublist[1], ')'
                    sys.exit(1)

            # now process the value from the CSV table
            # but first change any (decimal) comma do (decimal) point
            #   (and store it back also to the original table)
            cellTableLine[tcix] = cellTableLine[tcix].replace(',', '.')
            _msgstr = 'Error in input table:\n' + ', '.join(cellTableLine) + '\n'
            try:
                if clmnDescSublist[0] == 'f':
                    num = float( cellTableLine[tcix])
                else:
                    num = int( cellTableLine[tcix])
            except ValueError:
                _msgstr += 'Column ' + str(tcix+1) + ' (=' + str(cellTableLine[tcix]) + ') should be '
                if clmnDescSublist[0] == 'f':
                    _msgstr += 'a floating point number'
                else:
                    _msgstr += 'an integer number'
                grass.error(_msgstr)
                err = True
            except IndexError:
                _msgstr +=  'Line too short - column ' + str(tcix+1) + ' missing (number expected)'
                grass.error(_msgstr)
                err = True
            if nummin < nummax:
                if (num < nummin) or (num > nummax):
                    _msgstr += ('Number in column ' + str(tcix+1) + ' (=' + str(cellTableLine[tcix]) + ') is out of range ' +
                                str(nummin) + '..' + str(nummax))
                    grass.error(_msgstr)
                    err = True
            
        # string type - check against allowed list of string - possibly more than one list (variants)
        elif clmnDescSublist[0] == 's':
            if len(clmnDescSublist) < 2:
                print "??? INTERNAL ERROR - type 's' should have one or more additonal parameter(s) (list(s))"
                sys.exit(1)
            ixstr = 0
            for strlst in clmnDescSublist[1:]:
                ixstr += 1
                if not isinstance(strlst, list):
                    print "??? INTERNAL ERROR (cellTableDescrib) - 's'  should be followed by lists(s) of strings"
                    sys.exit(1)
                # now process the value from the CSV table
                _msgstr = 'Error in input table:\n' + ', '.join(cellTableLine) + '\n'
                try:
                    if cellTableLine[tcix] in strlst:
                        vix *= ixstr  # matching string found - OK
                        break
                except IndexError:
                    _msgstr += 'Line too short - column ' + str(tcix+1) + ' missing (string expected)'
                    grass.error(_msgstr)
                    err = True
                    break
            else:
                _msgstr = 'Error in input table:\n' + ', '.join(cellTableLine) + '\n'
                _msgstr += 'String in column ' + str(tcix+1) + ' (=' + str(cellTableLine[tcix]) + ') is not allowed. Allowed: '
                fullstrlst = []
                for strlst in clmnDescSublist[1:]:
                    fullstrlst.extend(strlst)
                _msgstr += ', '.join(fullstrlst)
                grass.error(_msgstr)
                err = True

        # special ("user label") string type - the following characters alre allowed:
        #     'A..Z', 'a..z', '0..9', '_', '-'
        elif clmnDescSublist[0] == 'ul':
            if len(clmnDescSublist) != 1:
                print "??? INTERNAL ERROR cellTableDescrib - type 'ul' should have no additonal parameter (list)"
                sys.exit(1)
            if re.search(r'[^A-Za-z0-9_-]', cellTableLine[tcix]):
                _msgstr = 'Error in input table:\n' + ', '.join(cellTableLine) + '\n'
                _msgstr += 'Wrong string in column ' + str(tcix+1) + ' (=' + str(cellTableLine[tcix]) + ').'
                _msgstr += " Allowed chars: 'A..Z', 'a..z', '0..9', '_', '-'"
                grass.error(_msgstr)
                err = True

        else:
            print '??? INTERNAL ERROR - invalid type definition in cellTableDescrib ( =', clmnDescSublist[0], ')' 
            sys.exit(1)

if err:
    grass.fatal('Exiting - error(s) found in input table parameters')



# ---- COMPUTATION REGION MANAGEMENT

import subprocess
import atexit


def gen_report_region(regDict):
    """
    Generate region report string:
      n         nn
    w   e  = nn    nn        res = nn    ewres = nn    nres = nn
      s         nn
    """
    nStr = wStr = sStr = eStr = '?'
    try:
        wStr = regDict['w']
    except:
        pass
    try:
        nStr = regDict['n']
    except:
        pass
    try:
        sStr = regDict['s']
    except:
        pass
    try:
        eStr = regDict['e']
    except:
        pass

    lenWstr = len(wStr)
    lenNSstr = max(len(nStr), len(sStr))
    lenEstr = len(eStr)

    msgLine1 = '      n      ' + lenWstr * ' ' + ' ' + nStr.rjust(lenNSstr)
    msgLine2 = '    w   e =  ' + wStr          + ' ' + lenNSstr * ' '        + ' ' + eStr + 8 * ' '
    msgLine3 = '      s      ' + lenWstr * ' ' + ' ' + sStr.rjust(lenNSstr)

    for resKey in ['res', 'ewres', 'nsres']:
        try:
           res = regDict[resKey]
           msgLine2 += resKey + ' = ' + res + '    '
        except:
            pass

    return msgLine1 + '\n' + msgLine2.rstrip() + '\n' + msgLine3


def set_region(regDict):
    regionCmd = ['g.region']
    for key in ['e', 'n', 's', 'w', 'res', 'ewres', 'nsres']:
        try:
            val = regDict[key]
            regionCmd.append(key + '=' + val)
        except:
            pass
    if subprocess.call(regionCmd):
        sys.exit(1)


def init_getCSVparam(keyList, paramList):
    """
    Retrieve parameter value (as string) by its header name (string) from the input (CSV) table
    """
    def getCSVparam(key):
        try:
            retstr = paramList[refCellTableHeader.index(key)]
        except (ValueError, IndexError):
            print '??? INTERNAL ERROR - unknown key string (parameter name) (=', key, ') while building commands' 
            sys.exit(1)
        return retstr
    return getCSVparam

#----------------

# get and save the current region parameters for later restoration
regionOld = grass.region()
atexit.register(set_region, regionOld)

#demFilename = 'dem_ljutomer_25@PERMANENT'
demFilename = options['dem_map']

# create a new region as defined by the region parameters (computation region), and store it
regionStr = options['region']
regionStr = regionStr.replace(':', '=').replace(',', ' ')
if regionStr == 'current':
    pass
else:
    if regionStr == 'dem':
        regionStr = 'rast=' + demFilename
    keyValList = regionStr.split()
    regionCmd = ['g.region']
    for keyVal in keyValList:
        if len(keyVal.split('=')) != 2:
            grass.fatal('Wrong region parameter definition: ' + keyVal)
        [key, val] = keyVal.split('=')
        if key not in ['region', 'rast', 'n', 'e', 's', 'w', 'res']:
            grass.fatal('Unknown region parameter: ' + keyVal)
        if key in ['n', 'e', 's', 'w', 'res']:
            # region is defined numerically
            if not val.isdigit():
                grass.fatal('Not a valid parameter value: ' + keyVal)
        regionCmd.append(key + '=' + val)
    if subprocess.call(regionCmd):
        grass.fatal('Region parameters: ' + str(regionCmd[2:]))

# "refine" the region: align to resolution, resolution rounded to integer value, the same in both directions
regionNotRefined = grass.region()
res = int(round(float(regionNotRefined['ewres'])))
##regionCmd = ['g.region', '-a', 'res=' + str(res)]  #this doesn't work well
wFl = float(regionNotRefined['w'])
eFl = float(regionNotRefined['e'])
nFl = float(regionNotRefined['n'])
sFl = float(regionNotRefined['s'])
wCompute = int(int(wFl) // res) * res
eCompute = int(int(eFl) // res) * res
nCompute = int(int(nFl) // res) * res
sCompute = int(int(sFl) // res) * res
if wCompute != wFl: wCompute += res
if sCompute != sFl: sCompute += res
regionCmd = ['g.region', 'w=' + str(wCompute), 'e=' + str(eCompute),
             'n=' + str(nCompute), 's=' + str(sCompute), 'res=' + str(res)]
if subprocess.call(regionCmd):
    sys.exit(1)
regionCompute = grass.region()
##print '****** Region new:\n' + gen_report_region(grass.region())
set_region(regionOld)
##print '****** Region old:\n' + gen_report_region(grass.region())
##print '****** regionCompute:\n' + gen_report_region(regionCompute)
##print '****** regionCompute:\n', regionCompute


# ---- FROM cellTable KEEP ONLY THE CELLS HAVING EFFECT INSIDE THE COMPUTATION REGION ----
# ---- and define the extended computation region (encompasing all the remaining cells)

cellTableReduced = []
wExtended = wCompute
eExtended = eCompute
nExtended = nCompute
sExtended = sCompute
for row in cellTable:
    gCSVp = init_getCSVparam(refCellTableHeader, row)
    cellRadius = 1000 * int(gCSVp('radius'))
    cellEast = int(gCSVp('positionEast'))
    cellNorth = int(gCSVp('positionNorth'))
    if (cellEast  < wCompute - cellRadius or
        cellEast  > eCompute + cellRadius or
        cellNorth > nCompute + cellRadius or
        cellNorth < sCompute - cellRadius):
        pass
    else:
        cellTableReduced.append(row)
        if cellEast  < wExtended: wExtended = int(cellEast // res) * res
        if cellEast  > eExtended: eExtended = int(cellEast // res) * res + res
        if cellNorth > nExtended: nExtended = int(cellNorth // res) * res + res
        if cellNorth < sExtended: sExtended = int(cellNorth // res) * res
cellTable = cellTableReduced

#define the extended computation region
regionCmd = ['g.region', 'w=' + str(wExtended), 'e=' + str(eExtended),
             'n=' + str(nExtended), 's=' + str(sExtended), 'res=' + str(res)]
if subprocess.call(regionCmd):
    sys.exit(1)
regionExtCompute = grass.region()
##print '****** regionExtCompute:\n' + gen_report_region(regionExtCompute)
##print '****** regionExtCompute:\n', regionExtCompute
set_region(regionOld)


# ---- REMOVE CELLS WITH TRANSMITTER LOCATION NOT DEFINED IN DEM

#testRegionList = [regionExtCompute, regionCompute, regionOld]
testRegionList = [regionExtCompute]
for testRegion in testRegionList:
    set_region(testRegion)
    cellTableReduced = []
    for row in cellTable:
        gCSVp = init_getCSVparam(refCellTableHeader, row)
        cellEastNorthStr = gCSVp('positionEast') + ',' + gCSVp('positionNorth')
        whatAnsw = grass.read_command('r.what', input = demFilename, east_north = cellEastNorthStr)
        # re.sub (below) returns height from r.what output, e.g. '590000|151985||212' -> '212'
        heightStr = re.sub(r'.*?\|.*?\|.*?\|', '', whatAnsw)
        if heightStr[0] == '*':
            grassMsg = ('Cell ' + gCSVp('userLabel') + ' removed from simulation ' + 
                        '(transmitter location ' + cellEastNorthStr + ' not defined in DEM)')
            if testRegion == regionExtCompute: grassMsg += ' (regionExtCompute)'
            elif testRegion == regionCompute: grassMsg += ' (regionCompute)'
            elif testRegion == regionOld: grassMsg += ' (current region)'
            grass.warning(grassMsg)
        else:
            cellTableReduced.append(row)
    cellTable = cellTableReduced
set_region(regionOld)



# ---- PREPARE GRASS_GIS MODEL PROCESSING (hata, ...) ----

grass.info('\nGETTING THE LIST OF EXISTING MODEL AND SECTOR FILES\n' +
             'FROM PREVIOUS SIMULATION RUNS IN THE CURRENT MAPSET...')

# get the list of existing files in current (users's) mapset
p = grass.pipe_command("g.mlist", mapset=mapset)
existingFilesList = p.communicate()[0].splitlines()


freq = options['frequency']
cmFilename = options['clutter_map']
fRecalc = flags['r']
odefh = options['default_height']
odefc = options['default_clutter']

requiredModSecFilesList=[]

modelFilenameList=[]
modelCmdList=[]

for row in cellTable:
    gCSVp = init_getCSVparam(refCellTableHeader, row)
    modelName = gCSVp('model')
    modelFilename = ('_' + 
                     modelName + '_' + gCSVp('P1') + '_' + gCSVp('P2') + '_' + gCSVp('P3') + '_' + gCSVp('P4') + '_' + 
                     gCSVp('P5') + '_' +
                     gCSVp('positionEast') + '_' + gCSVp('positionNorth') + '_' + gCSVp('heightAGL') + '_' + 
                     gCSVp('radius') + '_' + freq)
    if not modelFilename in requiredModSecFilesList:
        requiredModSecFilesList.append(modelFilename)
    if  modelFilename not in modelFilenameList:
        # check for file existence
        if fRecalc or not modelFilename in existingFilesList:
            # file does not exist yet (or recalculation of all files required), proceed
            modelFilenameList.append(modelFilename)

            # model hata (GRASS command r.hata)
            if modelName == 'hata':
                modelCmd = ('r.hata input=' + demFilename + ' output=' + modelFilename +
                            ' coordinate=' + gCSVp('positionEast') + ',' + gCSVp('positionNorth') +
                            ' ant_height=' + gCSVp('heightAGL') + ' radius=' + gCSVp('radius') +
                            ' area_type=' + gCSVp('P1') + ' frequency=' + freq + ' --overwrite')

            # model ericsson (GRASS command r.ericsson)
            elif modelName == 'ericsson':
                if cmFilename == '':
                    grass.fatal('Ericsson model requires a clutter_map file to be specified')
                modelCmd = ('r.ericsson input=' + demFilename + ' clutter_map=' + cmFilename + ' output=' + modelFilename +
                            ' A0=' + gCSVp('P1') + ' A1=' + gCSVp('P2') + ' A2=' + gCSVp('P3') + ' A3=' + gCSVp('P4') + 
                            ' coordinate=' + gCSVp('positionEast') + ',' + gCSVp('positionNorth') +
                            ' ant_height=' + gCSVp('heightAGL') + ' radius=' + gCSVp('radius') +
                            ' frequency=' + freq + ' --overwrite')
                # Conditionally add default_clutter parameter
                if odefc != '':
                    modelCmd += ' default_CLUT_value=' + odefc

            # model cost231 (GRASS command r.cost231)
            elif modelName == 'cost231':
                modelCmd = ('r.cost231 input=' + demFilename + ' output=' + modelFilename +
                            ' coordinate=' + gCSVp('positionEast') + ',' + gCSVp('positionNorth') +
                            ' ant_height=' + gCSVp('heightAGL') + ' radius=' + gCSVp('radius') +
                            ' area_type=' + gCSVp('P1') + ' frequency=' + freq + ' --overwrite')

            # model Walfisch-Ikegami (GRASS command r.waik)
            elif modelName == 'waik':
                if cmFilename == '':
                    grass.fatal('Walfisch-Ikegami model requires a clutter_map file to be specified')
                modelCmd = ('r.waik input=' + demFilename + ' clutter_map=' + cmFilename + ' output=' + modelFilename +
                            ' w=' + gCSVp('P2') + ' b=' + gCSVp('P3') + ' Hroof=' + gCSVp('P4') + ' PHI_Street=' + gCSVp('P5') +
                            ' area_type=' + gCSVp('P1') + 
                            ' coordinate=' + gCSVp('positionEast') + ',' + gCSVp('positionNorth') +
                            ' ant_height=' + gCSVp('heightAGL') + ' radius=' + gCSVp('radius') +
                            ' frequency=' + freq + ' --overwrite')
                # Conditionally add default_clutter parameter
                if odefc != '':
                    modelCmd += ' default_CLUT_value=' + odefc

            else:
                print '??? INTERNAL ERROR - unknown model (=', modelName, ')'

            # Conditionally add default_DEM_height parameter
            if odefh != '':
                modelCmd += ' default_DEM_height=' + odefh

            modelCmdList.append([modelCmd, gCSVp('userLabel')])


# ---- PREPARE GRASS_GIS SECTOR PROCESSING ----

sectorFilenameList=[]
sectorCmdList=[]
maxPowerSecList=[]

for row in cellTable:
    gCSVp = init_getCSVparam(refCellTableHeader, row)
    modelName = gCSVp('model')
    modelFilename = ('_' + 
                     modelName + '_' + gCSVp('P1') + '_' + gCSVp('P2') + '_' + gCSVp('P3') + '_' + gCSVp('P4') + '_' + 
                     gCSVp('P5') + '_' +
                     gCSVp('positionEast') + '_' + gCSVp('positionNorth') + '_' + gCSVp('heightAGL') + '_' + 
                     gCSVp('radius') + '_' + freq)
    sectorFilename = (gCSVp('userLabel').replace('_','') +
                      modelFilename + '_' + gCSVp('beamDirection') + '_' + gCSVp('electricalTiltAngle') + '_' +
                      gCSVp('mechanicalAntennaTilt') + '_' + gCSVp('antennaType'))
    requiredModSecFilesList.append(sectorFilename)
    if sectorFilename in sectorFilenameList:
        print '??? INTERNAL ERROR - duplicated sector in input table (should have been reported)'
        sys.exit(1)
    # prepare data for MaxPower
    maxPowerSec = (gCSVp('userLabel') + ';' + sectorFilename + '@' + mapset + ';' +
                   gCSVp('power') + ';' + modelName + ';' +
                   gCSVp('P1') + ';' + gCSVp('P2') + ';' + gCSVp('P3') + ';' + gCSVp('P4') + ';' + gCSVp('P5'))
    maxPowerSecList.append(maxPowerSec) 
    # check for file existence
    if fRecalc or not sectorFilename in existingFilesList:
        # file does not exist yet (or recalculation of all files required), proceed
        try:
            antMSIpath = antDict[gCSVp('antennaType'), int(gCSVp('electricalTiltAngle'))]
        except KeyError:
            grass.fatal('No .MSI file found for antenna type ' + gCSVp('antennaType') +
                        ' and electrical tilt ' + gCSVp('electricalTiltAngle'))
        sectorFilenameList.append(sectorFilename)
        sectorCmd = ('r.sector pathloss_raster=' + modelFilename + '@' + mapset +
                     ' DEM_raster=' + demFilename + ' output=' + sectorFilename +
                     ' ant_data_file=' + antMSIpath + ' beam_direction=' + gCSVp('beamDirection') +
                     ' mech_tilt=' + gCSVp('mechanicalAntennaTilt') + ' height_agl=' + gCSVp('heightAGL') +
                     ' radius=' + gCSVp('radius') +
                     ' east=' + gCSVp('positionEast') + ' north=' + gCSVp('positionNorth') + ' --overwrite')
        # Conditionally add default_DEM_height parameter
        if odefh != '':
            sectorCmd += ' default_DEM_height=' + odefh

        sectorCmdList.append([sectorCmd, gCSVp('userLabel')])


# ---- DELETE EXISTING FILES NOT REQUIRED BY THIS SIMULATION RUN (for all defined channel models) ----

grass.info('\nDELETING UNNEEDED MODEL AND SECTOR FILES FROM\n' +
             'PREVIOUS SIMULATION RUNS IN THE CURRENT MAPSET...')

fPurge = flags['p']

if fPurge:
    # make a list of defined models (e.g. ['hata', 'ericsson'])
    modelList = []
    for clmn in cellTableDescrib:
        if clmn[0] == 'model':
            for mlist in clmn[2:]:
               modelList.extend(mlist)

    # list of those files with filenames starting with a defined channel model name, posibly preceeding with a userLabel
    # files will be deleted if not needed in this simulation run
    ndel = 0
    delFileList = []
    for fname in existingFilesList:
        fnameNolabel = fname[fname.find('_'):]
        for model in modelList:
            if fname.startswith('_' + model + '_') or fnameNolabel.startswith('_' + model + '_'):
                if not fname in requiredModSecFilesList:
                    delFileList.append(fname)
                    ndel += 1
                break
    if ndel == 0:
        grass.info('Purge: no files deleted')
    else:
        _msgstr = 'Purge: the following file are not needed by this run and will be deleted:\n'
        for fname in delFileList:
            _msgstr += fname + '\n'
        grass.info(_msgstr)
        for fname in delFileList:
            grass.run_command("g.remove",rast=fname)



# ---- COMMANDS EXECUTION (MODEL, SECTOR) ----

## parNum = int(options['procnum'])


# old single-core version:
#def execCmds(cmdList):
#def exec_cmds1(cmdList, parMax):
#    """Processes commands from commnad list, returns False in case of an error, True otherwise"""
#
#    for ix, [cmd, secName] in enumerate(cmdList):
#        grass.info('> ' + secName + ' (' + str(ix+1) + './' + str(len(cmdList)) + ')\n' + cmd)
#        iret = subprocess.call(cmd, shell=True)
#        if iret != 0:
#            return False
#    return True


def grass_parcmds( cmd_a, ix, spMax):
    """
    Parallel execution of grass command execution (speedup for multicore processors)
    """ 
    global __spList  # subprocess list - local use but it should persist between procedure invocations

    # check if __spList exists, otherwise create it (first calling)
    try:
        __spList
    except NameError:
        __spList = []

    # loop slowly until:
    #  - a new subprocess can be started (limited by max number of subprocesses - spMax)
    #  - and the number of running subprocesses falls (again) below spMAX (usually spMax-1 on exit)
    while True:
        # check for finished subprocesses, delete them from the subprocess list (__spList)
        for ixsp, [sp, ixold] in enumerate(__spList):
            iret = sp.poll()
            if iret != None:
                # a subprocess has finished
                grass.info('< (' + str(ixold+1) + './_)')

                 # print stdout and stderr
                (stdoutdata, stderrdata) = sp.communicate()
##                # discard cahacters after the last '\n',
##                #   then delete the final '\n' (actually final whitespaces) if any
##                stdoutdata = stdoutdata[0:(stdoutdata.rfind('\n')+1)].rstrip()
##                stderrdata = stderrdata[0:(stderrdata.rfind('\n')+1)].rstrip()
                # remove "%" progress substrings (like '  29%<BS><BS><BS><BS><BS>')
                # remove re.sub(r'\ [\ 0-9]{3,3}%\t{5,5}','','  29%\b\b\b\b\b')
                stdoutdata = re.sub(r' [ 0-9]{3,3}%[\b]{5,5}','',stdoutdata)
                stderrdata = re.sub(r' [ 0-9]{3,3}%[\b]{5,5}','',stderrdata)
                # remove final '\n'(s) if any
                stdoutdata = re.sub(r'\n*\Z','',stdoutdata)
                stderrdata = re.sub(r'\n*\Z','',stderrdata)
                if len(stdoutdata) > 0:
                    grass.info( '(O)' + stdoutdata)
                if len(stderrdata) > 0:
                    grass.info( '(E)' + stderrdata)

                if iret != 0:
                    # there was an error -> no further processing, just return
                    return iret
                # subprocess finished successfully - clean up and proceed
                __spList.pop(ixsp)

        # if no room available for a new process-> sleep a bit
        # if room available for a new process -> start it and clear cmd_a
        # if no process to start (cmd_a == []) -> return
        if len(__spList) < spMax:
            if cmd_a != []:
               sp = subprocess.Popen(cmd_a, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
##               sp = subprocess.Popen(cmd_a)
               __spList.append([sp,ix])
               cmd_a = []
            else: return 0
        else: time.sleep(0.2)


def exec_cmds(cmdList, parMax):
    """
    Processes commands from commnad list, returns False in case of an error, True otherwise
    """ 
    for ix, [cmd, secName] in enumerate(cmdList):
        grass.info('> ' + secName + ' (' + str(ix+1) + './' + str(len(cmdList)) + ')\n' + cmd)
        # evaluate GISBASE enviroment variable
        cmd_eval = cmd.replace('$GISBASE',os.getenv('GISBASE'))
        cmd_a = cmd_eval.split()
        if parMax == 0:
            # non-parallel execution

##            east_northStr = cmd_a[8].replace('coordinate', 'east_north')  ########
##            cmdWhat = ['r.what', 'input=' + demFilename, east_northStr]   ########
##            print cmdWhat                                                 ########
##            subprocess.call(cmdWhat)                                      ########

##            iret = subprocess.call(cmd, shell=True)  # (this is not really safe)
            iret = subprocess.call(cmd_a)
        elif parMax > 0:
            # parallel execution - up to parMax parallel executions
            iret = grass_parcmds(cmd_a, ix, parMax)
        if iret != 0:
            return False

    # for parallel execution: wait to complete
    if parMax > 0:
        if grass_parcmds([], 0, 1) != 0:
            return False

    return True

#----------------


grass.info('\nSTARTING RADIO COVERAGE COMPUTATION...')

import time

fCheck = flags['c']

if modelCmdList != []:
    grass.info('          \n----- PROCESSING MODELS -----')

    # set the extended computation region
    grass.info('Temporarily changing the existing current region:\n' + gen_report_region(regionOld) +
               '\nto the extended computation region:\n' + gen_report_region(regionExtCompute))
    set_region(regionExtCompute)
    timeModels0 = time.time()
    if not fCheck:
        if not exec_cmds(modelCmdList, parNum):
            grass.fatal("Error(s) while processing 'model' commands, exiting")
    else:
        grassMsg = 'This is a test run only, the following model commands would be executed:\n'
        for row in modelCmdList:
           grassMsg += row[0] + '\n'
        grass.info(grassMsg)
    timeModels1 = time.time()
    dTimeModels = timeModels1 - timeModels0


if sectorCmdList != []:
    grass.info('          \n----- PROCESSING SECTORS -----')
    timeSectors0 = time.time()
    if not fCheck:
        if not exec_cmds(sectorCmdList, parNum):
            grass.fatal("Error(s) while processing 'sector' commands, exiting")
    else:
        grassMsg = 'This is a test run only, the following model commands would be executed:\n'
        for row in sectorCmdList:
           grassMsg += row[0] + '\n'
        grass.info(grassMsg)
    timeSectors1 = time.time()
    dTimeSectors = timeSectors1 - timeSectors0


# ---- MAX POWER ----

if maxPowerSecList == []:
    grass.info('Nothing to calculate (no sectors specified)')
else:

    import tempfile

    cellNum = options['cellnum']

    grass.info('          \n----- GENERATING FINAL RESULTS - RASTER MAP AND DB (OPTIONALLY) -----')

    # set the computation region
    grass.info('Temporarily changing current region to the computation region:\n' +
               gen_report_region(regionCompute))
    set_region(regionCompute)

    # Create intermediate (temporary) radio cell/sector table file
    tmpFile = tempfile.NamedTemporaryFile()
    tmpFile.write(str(len(maxPowerSecList)) + '\n')
    for row in maxPowerSecList:
        tmpFile.write(row + ';;\n')
    tmpFile.flush()


    dbDriverName = options['db_driver']
    databaseName = options['database']

    # create db file (optionally)
    if dbDriverName != 'none':
        mpcmd = ('db.GenerateTable -o table=' + dbFilename + ' driver=' + dbDriverName +
                 ' database=' + databaseName + ' cell_num=' + str(cellNum))
        grass.info('> CREATE (EMPTY) DATA TABLE\n' + mpcmd)
        timeCreateDB0 = time.time()
        if fCheck:
            grass.info('This is a test run only, the above db.GenerateTable command will not be executed')
        else:
##            iret = subprocess.call(mpcmd, shell=True)
            mpcmd_a = mpcmd.split()
            iret = subprocess.call(mpcmd_a)
            if iret != 0:
                grass.fatal('Error while generating db file, exiting')
        timeCreateDB1 = time.time()
        dTimeCreateDB = timeCreateDB1 - timeCreateDB0

    mpcmd = ("r.MaxPower 'cell_input=" + tmpFile.name + "' output=" + outFilename + ' table=' + dbFilename +
             ' driver=' + dbDriverName + " 'database=" + databaseName + "' --overwrite")
    if dbDriverName == 'none':
        grass.info('> WRITE RASTER MAP ONLY\n' + mpcmd)
    else:
        grass.info('> WRITE RASTER MAP AND DATA TABLE\n' + mpcmd)
    timeWriteDB0 = time.time()
    if fCheck:
        grass.info('This is a test run only, the above r.MaxPower command will not be executed')
    else:
        iret = subprocess.call(mpcmd, shell=True)
        if iret != 0:
            grass.fatal('Error while creating final output files (DB and raster), exiting')
    timeWriteDB1 = time.time()
    dTimeWriteDB = timeWriteDB1 - timeWriteDB0


    # Debugging: display the temporary file
    if fCheck:
        grassMsg = 'A temporary file (' + tmpFile.name + ') has been created for r.MaxPower with the following contents:\n'
        tmpFile.seek(0)
        for row in tmpFile:
            grassMsg += row
##        tmpFile.seek(0)
        grass.info(grassMsg)

##    tmpFile.close()


##grass.info('Restoring the original current region:\n' + gen_report_region(regionOld)
##set_region(regionOld)

if modelCmdList != []:
    grass.info('Processing of %i model(s) took %.2f[s], i.e. %.2f[s/model]'
                % (len(modelCmdList), dTimeModels, dTimeModels/len(modelCmdList)))
if sectorCmdList != []:
    grass.info('Processing of %i sector(s) took %.2f[s], i.e. %.2f[s/sector]'
                % (len(sectorCmdList), dTimeSectors, dTimeSectors/len(sectorCmdList)))
if maxPowerSecList != []:
    if dbDriverName != 'none':
        grass.info('Creation of (empty) data table took %.2f[s]' % dTimeCreateDB)
        grass.info('Writing of output raster map and data table took %.2f[s]' % dTimeWriteDB)
    else:
        grass.info('Writing of output raster map took %.2f[s]' % dTimeWriteDB)

grass.info('Processing finished')
